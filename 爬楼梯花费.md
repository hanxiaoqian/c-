#标题：爬楼梯花费

##分类：递归

##发表于：2019-05-11 23:18:05

#一、题目要求
###以数组索引为楼梯数，每个楼梯对应花费体力值（非负），一次仅能爬1-2节，寻找最少体力花费。
示例1:输入：cost[10 15 20]
> > > 输出：15
示例2:输入：cost[1 100 1 1 1 100 1 1 100 1]
> > > 输出：6

二、题目分析
一开始想着正向查找，将cost[0]、cost[1]进行比较，如果cost[0]中数据小，则将cost[0]加到pay上，否则将pay+=cost[1]。然后让索引往下依次循环，索引增加1/2用if-else进行操作，并以0为结束。写完后发现第一个示例便出现错误，示例1结果必然为15，而我输出的则是30。因此我便写了一个[1 2 3 4 5]。如果按从开始爬，那么结果为9，而最少明显是6。又写了[2 9 10 3 4],答案应该是12。最终通过网络的帮助，发现从楼顶开始往回走，上述三种都成立。逆向你必须走1/2步，而找出最小花费，你必须再回退找出前面两节的最小花费，这样出来的结果肯定为最小花费。而从头开始走，如果正向比逆向多走一步，那么他不是最小花费。
三、解题思路
利用递归返回当前楼梯的前两节台阶中更小的花费。
四、代码
#include<stdio.h>
#define N 100

int mincost(int cost[],int n)
{
	if(n<0)
	return 0;
	if(cost[n-2]<=cost[n-1])
	return mincost(cost,n-2)+cost[n-2];
	else
	return mincost(cost,n-1)+cost[n-1];
}

int main()
{
	int i=0,m=1,count,pay=0;
	int cost[N];
	printf("请输入走每一步需要的花费值：\n");
	while(m)
	{
		scanf("%d",&cost[i]);
		m=cost[i];
		i++;
	}
	pay=mincost(cost,i--);
	printf("你需要消耗的体力值为%d:",pay);
	return 0;
}
五、心得体会
看似简单的一个问题，按照常规思路也是很难找到突破口的，像这个问题应该逆向来考虑。算法题之所以叫算法题，这就是精髓。自己还是学的太慢太基础，算法题接触的少，在思考问题上有点普通化。多问多学多请教才能变得更优秀！

----张晓龙